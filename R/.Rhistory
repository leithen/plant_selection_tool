rm(list=ls())library(mosaic)?hybrid.zone
hybrid.zone
data(hybrid.zone)
hybrid.zone
data(hybrid.zone)#
hybrid.zone
rm(list=ls())library(mosaic)?hybrid.zone
data(hybrid.zone)#
hybrid.zone
data(hybrid.zone)res <- fit.mosaic(hybrid.zone, 0.05)
sum.steps
rm(list=ls())library(mosaic)?hybrid.zone
rm(list=ls())library(mosaic)?hybrid.zone?sum.step.heights?plot.mosaic?make.mosaic.logLik?fit.mosaic?plotMosaicdata(hybrid.zone)res <- fit.mosaic(hybrid.zone, 0.05)plotMosaic(hybrid.zone, res[[length(res)]]$best.model)best.model <- res[[length(res)]]$best.modelsum.step.heights(hybrid.zone, best.model)
?hybrid.zone
hybrid.zone
?plot
rm(list=ls())library(mosaic)
?sum.step.heights
rm(list=ls())library(mosaic)?sum.step.heights
data(hybrid.zone)#
res <- fit.mosaic(hybrid.zone, 0.05)#
best.model <- res[[length(res)]]$best.model#
sum.step.heights(hybrid.zone, best.model)
plot(res)
?plot
?verbose
rm(list=ls())library(mosaic)
?fit.mosaic
?lapply
rm(list=ls())library(mosaic)?fit.mosaic
?plot.mosaic
?hybrid.zone
rm(list=ls())library(mosaic)?fit.mosaic
rm(list=ls())library(mosaic)?make.mosaic.logLik?fit.mosaic?sum.step.heights?hybrid.zone?plot.mosaic?plotMosaic
data(hybrid.zone)res <- fit.mosaic(hybrid.zone, 0.05)plot(res)
make.mosaic.logLik(hybrid.zone)
x <- make.mosaic.logLik(hybrid.zone)
x
make.mosaic.logLik
c
x
x(1)
x(2)
x(3)
rm(list=ls())library(mosaic)
?make.mosaic.logLik
data(hybrid.zone)res <- fit.mosaic(hybrid.zone, 0.05)plot(res)
rm(list=ls())library(mosaic)
?make.mosaic.logLik
?fit.mosaic
?mosaicity
rm(list=ls())library(mosaic)
?make.mosaic.logLik
?fit.mosaic
?mosaicity
?hybrid.zone
?plot.mosaic
 library(help=mosaic)
plot(1:10)title(main="blah blah", outer=TRUE)
plot(1:10)title(main="blah blah")
library(geiger)
?geiger
library(geiger)
56.9+27.88+34.4+25.26+17.21+63.47+36.15+47.84
4047-990-1672
4047-990-1031-1672
4047-990-1031-1672+768
2e-7
2e-7/0.9
2e-7/1.8
2e-7/0.45
sqrt(1e-7/0.9)
sqrt(2e-7/0.9)
837/1087
814/1056
793/1021
774/1009
838/1087
36+36+41+41+42
36+37+37+41+41
36+37+37+42+42
36+38+38+42+42
934/1226
904/1196
944/1242
913/1208
3/8*25/80
15000/0.776
15000/0.7175
x <- 5
5+7
run.sim <- function() {  Sys.sleep(0.1)  runif()}
x <- run.sim()
run.sim <- function() {  Sys.sleep(0.1)  runif()}x <- run.sim()
run.sim <- function() {  Sys.sleep(0.1)  runif(1)}x <- run.sim()
prms.f <-  function(a, b) {  prms <- list(a, b)  names(prms) <- c("a", "b")  prms}prms <- prms.f(a=1,               b=1)run.sim <- function() {  Sys.sleep(0.1)  runif(1)}x <- run.sim()
x
## here is a toy simulation you can use to get an idea how to## replicate simulations and to run them over various parameter## combinations## parameter list (say we have two parameters 'a' and 'b'prms.f <-  function(a, b) {  prms <- list(a, b)  names(prms) <- c("a", "b")  prms}prms <- prms.f(a=1,               b=1)
prms
## here is a toy simulation you can use to get an idea how to## replicate simulations and to run them over various parameter## combinations## parameter list (say we have two parameters 'a' and 'b'prms.f <-  function(a, b) {  prms <- list(a, b)  names(prms) <- c("a", "b")  prms}prms <- prms.f(a=1,               b=1)## our simulation which just returns a * (random number) + b after 0.1## secondsrun.sim <- function(prms) {  Sys.sleep(0.1)  prms$a * runif(1) + prms$b}x <- run.sim(prms)
x
?list
stored <- vector("list", 100)
stored
stored <- vector("list", 100)for(i in 1:100)  stored[[i]] <- run.sim(prms)
## here is a toy simulation you can use to get an idea how to## replicate simulations and to run them over various parameter## combinations## parameter list (say we have two parameters 'a' and 'b'prms.f <-  function(a, b) {  prms <- list(a, b)  names(prms) <- c("a", "b")  prms}prms <- prms.f(a=1,               b=1)## our simulation which just returns a * (random number) + b## secondsrun.sim <- function(prms) {  prms$a * runif(1) + prms$b}x <- run.sim(prms)## so, if I wanted to see what happened if I ran it 100 times I could## do the following:stored <- vector("list", 100)for(i in 1:100)  stored[[i]] <- run.sim(prms)
stored
as.vector(stored)
mean(unlist(stored))
unlist(stored)
seq(from=1, to=500, length=10)
seq(from=log(0), to=log(500), length=10)
seq(from=log(1), to=log(500), length=10)
exp(seq(from=log(1), to=log(500), length=10))
list.b <- exp(seq(from=log(1), to=log(500), length=10))
list.b
plot(list.b)
## list of 'a' values of interest (say, 1 to 10)list.a <- 1:10## list of 'b' values of interest (say, 1 to 500 on a log scale)list.b <- exp(seq(from=log(1), to=log(500), length=10))
param.combinations <- expand.grid(a.list, b.list)
## list of 'a' values of interest (say, 1 to 10)list.a <- 1:10## list of 'b' values of interest (say, 1 to 500 on a log scale)list.b <- exp(seq(from=log(1), to=log(500), length=10))## and suppose I want 100 replicates of each combination of 'a' and## 'b'num.rep <- 100## so what I do is I make a list of all parameter combinationsparam.combinations <- expand.grid(a.list, b.list)
## list of 'a' values of interest (say, 1 to 10)a.list <- 1:10## list of 'b' values of interest (say, 1 to 500 on a log scale)b.list <- exp(seq(from=log(1), to=log(500), length=10))## and suppose I want 100 replicates of each combination of 'a' and## 'b'num.rep <- 100## so what I do is I make a list of all parameter combinationsparam.combinations <- expand.grid(a.list, b.list)
param.combinations
## here is a toy simulation you can use to get an idea how to## replicate simulations and to run them over various parameter## combinations## parameter list (say we have three parameters 'a', 'b' and 'c'prms.f <-  function(a, b, c) {  prms <- list(a, b, c)  names(prms) <- c("a", "b", "c")  prms}## our simulation which just returns a * (random number) + b## secondsrun.sim <- function(prms) {  prms$a * runif(1) + prms$b}prms <- prms.f(a=1, b=1, c=1)x <- run.sim(prms)## so, if I wanted to see what happened if I ran it 100 times I could## do the following:stored <- vector("list", 100)for(i in 1:100)  stored[[i]] <- run.sim(prms)## now, if I wanted to compute the mean value of my 100 simulations I## would domean(unlist(stored))## which should be close to 1.5 with a=1 and b=1#### for you you'll have to create a list of populations after 'n'## generations or some such thing and retrieve whichever trait of that## population that is of interest when you want to analyze your output
## now, suppose you wanted to analyze a whole bunch of parameter## combinations, but don't want to have to go in and manually change## parameters (quite tedious)## list of 'a' values of interest (say, 1 to 10)a.list <- 1:10## list of 'b' values of interest (say, 1 to 500 on a log scale)b.list <- exp(seq(from=log(1), to=log(500), length=10))## and suppose I want 100 replicates of each combination of 'a' and## 'b'num.rep <- 100
## list of 'a' values of interest (say, 1 to 10)a.list <- 1:10## list of 'b' values of interest (say, 1 to 500 on a log scale)b.list <- exp(seq(from=log(1), to=log(500), length=10))## and suppose I want 100 replicates of each combination of 'a' and## 'b'num.reps <- 100## so what I do is I make a list of all parameter combinationsparam.combinations <- expand.grid(a.list, b.list)
## list of 'a' values of interest (say, 1 to 10)a.list <- 1:10## list of 'b' values of interest (say, 1 to 500 on a log scale)b.list <- exp(seq(from=log(1), to=log(500), length=10))## and suppose I want 100 replicates of each combination of 'a' and## 'b'num.reps <- 100## so what I do is I make a list of all parameter combinationsparam.combinations <- expand.grid(a.list, b.list)run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  run.sim(prms)}
run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  sapply(1:nr) <- run.sim(prms)}
?mapply
run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  sapply(1:nr) <- run.sim(prms)}mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),       a=param.combinations[,1], b=param.combinations[,1])
param.combinations[,2]
mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),       a=param.combinations[,1], b=param.combinations[,2])
prms
run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  sapply(1:nr, function() run.sim(prms))}
mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),       a=param.combinations[,1], b=param.combinations[,2])
sapply(1:10, function() run.sim(prms))
sapply(1:10, function(x) run.sim(prms))
run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  sapply(1:nr, function(x) run.sim(prms))}
mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),       a=param.combinations[,1], b=param.combinations[,2])
run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  ## return the mean value of 100 simulations for this combination of  ## 'a' and 'b'  mean(sapply(1:nr, function(x) run.sim(prms)))}
mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),       a=param.combinations[,1], b=param.combinations[,2])
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))
res
image(res, col=grey(1:32))
image(res, col=grey(1:32/32))
image(t(res), col=grey(1:32/32))
image(t(res), col=grey(1:32/32), xlab="a", ylab="b")
image(t(res), col=grey(1:32/32), xlab="a", ylab="b", xaxt="", yaxt="")
image(t(res), col=grey(1:32/32), xlab="a", ylab="b", xaxt="n", yaxt="n")
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(t(res), col=grey(1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")
## list of 'a' values of interest (say, 1 to 10)a.list <- 1:10## list of 'b' values of interest (say, 1 to 50 on a log scale)b.list <- exp(seq(from=log(1), to=log(50), length=10))## and suppose I want 100 replicates of each combination of 'a' and## 'b'num.reps <- 100## so what I do is I make a list of all parameter combinationsparam.combinations <- expand.grid(a.list, b.list)run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  ## return the mean value of 100 simulations for this combination of  ## 'a' and 'b'  mean(sapply(1:nr, function(x) run.sim(prms)))}res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")
## list of 'a' values of interest (say, 1 to 10)a.list <- 1:10## list of 'b' values of interest (say, 1 to 25 on a log scale)b.list <- exp(seq(from=log(1), to=log(25), length=10))## and suppose I want 100 replicates of each combination of 'a' and## 'b'num.reps <- 100## so what I do is I make a list of all parameter combinationsparam.combinations <- expand.grid(a.list, b.list)run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  ## return the mean value of 100 simulations for this combination of  ## 'a' and 'b'  mean(sapply(1:nr, function(x) run.sim(prms)))}res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")axis(1, at=c(0,0.5,1), labels=c(0,5,10))
seq(from=1, to=25, length=4)
seq(from=1, to=25, length=4, log=TRUE)
?seq
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")axis(1, at=c(0,0.5,1), labels=c(0,5,10))axis(2, at=0:4/4,     labels=b.list <- exp(seq(from=log(1), to=log(25), length=5)))
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")axis(1, at=c(0,0.5,1), labels=c(0,5,10))axis(2, at=0:4/4, labels=b.list <-     round(exp(seq(from=log(1), to=log(25), length=5))), las=1)
run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  ## return the mean value of 100 simulations for this combination of  ## 'a' and 'b'  mean(sapply(1:nr, function(x) run.sim(prms)))}res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")axis(1, at=c(0,0.5,1), labels=c(0,5,10))axis(2, at=0:4/4, labels=b.list <-     round(exp(seq(from=log(1), to=log(25), length=5))), las=1)
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")axis(1, at=c(0,0.5,1), labels=c(0,5,10))axis(2, at=0:4/4, labels=b.list <-     round(exp(seq(from=log(1), to=log(25), length=5))))
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")axis(1, at=c(0,0.5,1), labels=c(0,5,10))
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")
## here is a toy simulation you can use to get an idea how to## replicate simulations and to run them over various parameter## combinations## parameter list (say we have three parameters 'a', 'b' and 'c'prms.f <-  function(a, b, c) {  prms <- list(a, b, c)  names(prms) <- c("a", "b", "c")  prms}## our simulation which just returns a * (random number) + b## secondsrun.sim <- function(prms) {  prms$a * runif(1) + prms$b}prms <- prms.f(a=1, b=1, c=1)x <- run.sim(prms)## so, if I wanted to see what happened if I ran it 100 times I could## do the following:stored <- vector("list", 100)for(i in 1:100)  stored[[i]] <- run.sim(prms)## now, if I wanted to compute the mean value of my 100 simulations I## would domean(unlist(stored))## which should be close to 1.5 with a=1 and b=1#### for you you'll have to create a list of populations after 'n'## generations or some such thing and retrieve whichever trait of that## population that is of interest when you want to analyze your output
## now, suppose you wanted to analyze a whole bunch of parameter## combinations, but don't want to have to go in and manually change## parameters (quite tedious)## list of 'a' values of interest (say, 1 to 10)a.list <- 1:10## list of 'b' values of interest (say, 1 to 25 on a log scale)b.list <- exp(seq(from=log(1), to=log(25), length=10))## and suppose I want 100 replicates of each combination of 'a' and## 'b'num.reps <- 100## so what I do is I make a list of all parameter combinationsparam.combinations <- expand.grid(a.list, b.list)run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  ## return the mean value of 100 simulations for this combination of  ## 'a' and 'b'  mean(sapply(1:nr, function(x) run.sim(prms)))}res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab=
"b",      xaxt="n", yaxt="n")
axis(1, at=c(0,0.5,1), labels=c(0,5,10))
axis(2, at=0:4/4, labels=b.list <-     round(exp(seq(from=log(1), to=log(25), length=5))))
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")axis(1, at=c(0,0.5,1), labels=c(0,5,10))axis(2, at=0:4/4, labels=b.list <-     round(exp(seq(from=log(1), to=log(25), length=5))), las=1)
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])
dim(res) <- c(length(a.list), length(b.list))
res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])
res
dim(res) <- c(length(a.list), length(b.list))
c(length(a.list), length(b.list))
## list of 'a' values of interest (say, 1 to 10)a.list <- 1:10## list of 'b' values of interest (say, 1 to 25 on a log scale)b.list <- exp(seq(from=log(1), to=log(25), length=10))## and suppose I want 100 replicates of each combination of 'a' and## 'b'num.reps <- 100## so what I do is I make a list of all parameter combinationsparam.combinations <- expand.grid(a.list, b.list)run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  ## return the mean value of 100 simulations for this combination of  ## 'a' and 'b'  mean(sapply(1:nr, function(x) run.sim(prms)))}res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))
res
## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")
axis(1, at=c(0,0.5,1), labels=c(0,5,10))axis(2, at=0:4/4, labels=b.list <-     round(exp(seq(from=log(1), to=log(25), length=5))), las=1)
a.list
b.list
## list of 'a' values of interest (say, 1 to 10)a.list <- 1:10## list of 'b' values of interest (say, 1 to 25 on a log scale)b.list <- exp(seq(from=log(1), to=log(25), length=10))## and suppose I want 100 replicates of each combination of 'a' and## 'b'num.reps <- 100## so what I do is I make a list of all parameter combinationsparam.combinations <- expand.grid(a.list, b.list)run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  ## return the mean value of 100 simulations for this combination of  ## 'a' and 'b'  mean(sapply(1:nr, function(x) run.sim(prms)))}res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab="b",      xaxt="n", yaxt="n")axis(1, at=c(0,0.5,1), labels=c(0,5,10))axis(2, at=0:4/4, labels=round(exp(seq(from=log(1), to=log(25),                    length=
5))), las=1)
## here is a toy simulation you can use to get an idea how to## replicate simulations and to run them over various parameter## combinations## parameter list (say we have three parameters 'a', 'b' and 'c'prms.f <-  function(a, b, c) {  prms <- list(a, b, c)  names(prms) <- c("a", "b", "c")  prms}## our simulation which just returns a * (random number) + b## secondsrun.sim <- function(prms) {  prms$a * runif(1) + prms$b}prms <- prms.f(a=1, b=1, c=1)x <- run.sim(prms)## so, if I wanted to see what happened if I ran it 100 times I could## do the following:stored <- vector("list", 100)for(i in 1:100)  stored[[i]] <- run.sim(prms)## now, if I wanted to compute the mean value of my 100 simulations I## would domean(unlist(stored))## which should be close to 1.5 with a=1 and b=1#### for you you'll have to create a list of populations after 'n'## generations or some such thing and retrieve whichever trait of that## population that is of interest when you want to analyze your output
## now, suppose you wanted to analyze a whole bunch of parameter## combinations, but don't want to have to go in and manually change## parameters (quite tedious)## list of 'a' values of interest (say, 1 to 10)a.list <- 1:10## list of 'b' values of interest (say, 1 to 25 on a log scale)b.list <- exp(seq(from=log(1), to=log(25), length=10))## and suppose I want 100 replicates of each combination of 'a' and## 'b'num.reps <- 100## so what I do is I make a list of all parameter combinationsparam.combinations <- expand.grid(a.list, b.list)run.sim.ab <- function(prms, a, b, nr) {  prms$a <- a  prms$b <- b  ## return the mean value of 100 simulations for this combination of  ## 'a' and 'b'  mean(sapply(1:nr, function(x) run.sim(prms)))}res <- mapply(function(a, b) run.sim.ab(prms=prms, a, b, nr=num.reps),              a=param.combinations[,1], b=param.combinations[,2])dim(res) <- c(length(a.list), length(b.list))## plot an image of the resultimage(res, col=grey(1-1:32/32), xlab="a", ylab=
"b",      xaxt="n", yaxt="n")axis(1, at=c(0,0.5,1), labels=c(0,5,10))axis(2, at=0:4/4, labels=round(exp(seq(from=log(1), to=log(25),                    length=5))), las=1)
56/180
sprintf("\n%d", 2)
cat(sprintf("\n%d", 2))
s <- sprintf("I have %d dogs, and the first one weighs %2.3f kg.", 4, 15.733211)#
cat(s, "\n")
set.seed(1)#
runif(10)#
set.seed(1)#
runif(10)
pollinator.ids <- 1:20plant.ids <- 1:30visitation <- length(pollinator.ids)*length(plant.ids)
visitation
pollinator.ids <- 1:20plant.ids <- 1:30visitation <- runif(length(pollinator.ids)*length(plant.ids))<0.2
visitation
num.pollinators <- 20num.plants <- 30visitation <- runif(num.pollinators*num.plants)<0.2
visitation
## create sample datasetnum.pollinators <- 20num.plants <- 30visitation <- runif(num.pollinators*num.plants)<0.2visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)
visitation.matrix
num.pollinators <- 20num.plants <- 30visitation <- runif(num.pollinators*num.plants)<0.2*1visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)
visitation.matrix
num.pollinators <- 20num.plants <- 30visitation <- (runif(num.pollinators*num.plants)<0.2)*1visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)
visitation.matrix
num.pollinators <- 20num.plants <- 30visitation <- (runif(num.pollinators*num.plants)<0.2)*1visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)
visitation.matrix
num.pollinators <- 20num.plants <- 30visitation <- (runif(num.pollinators*num.plants)<0.2)*1visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)
visitation.matrix
num.pollinators <- 20num.plants <- 30visitation <- (runif(num.pollinators*num.plants)<0.2)*1visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)
visitation.matrix
num.pollinators <- 20num.plants <- 30visitation <- (runif(num.pollinators*num.plants)<0.2)*1visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)
visitation.matrix
num.pollinators <- 10num.plants <- 15visitation <- (runif(num.pollinators*num.plants)<0.2)*1visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)
visitation.matrix
num.pollinators <- 10num.plants <- 15visitation <- (runif(num.pollinators*num.plants)<0.2)*1visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)
visitation.matrix
find.min.plant.set
colSums(visitation.matrix)
rowSums(visitation.matrix)
rs <- rowSums(visitation.matrix)which(rs==0)
rs <- rowSums(visitation.matrix)non.supported.pollinators <- which(rs==0)
non.supported.pollinators
rs <- rowSums(visitation.matrix)non.supported.pollinators <- which(rs==0)
non.supported.pollinators
id.non.supported.pollinator <- which(rs==0)
rs <- rowSums(visitation.matrix)
rs
num.pollinators <- 10num.plants <- 15visitation <- (runif(num.pollinators*num.plants)<0.2)*1visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)## pollinator.flight.periods## plant.phenologiesrs <- rowSums(visitation.matrix)id.non.supported.pollinator <- which(rs==0)
id.non.supported.pollinator
visitation.matrix
setwd("~/Documents/phd/brite/tool/mcmc")rm(list=ls())## create sample datasetnum.pollinators <- 10num.plants <- 15visitation <- (runif(num.pollinators*num.plants)<0.2)*1visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)## pollinator.flight.periods## plant.phenologiesrs <- rowSums(visitation.matrix)id.non.supported.pollinator <- which(rs==0)visitation.matrixmost.pollinators <- function(m)  sum(rowSums(visitation.matrix[,m])>0)## MCMC Stufftarget <- most.pollinatorsproposal <- function(m) {  x1 <- sample(which(m), size=1)  x2 <- sample(which(!m), size=1)  m[x1] <- !m[x1]  m[x2] <- !m[x2]  m}step <- function(m) { m.p <- proposal(m) alpha <- target(m.p) / target(m) if ( alpha > 1 || runif(1) < alpha ) m.p else m}run <- function(m, nsteps) { out <- vector(mode="list", length=nsteps) for ( i in seq_len(nsteps) )   m <- out[[i]] <- step(m) out}start <- runif(15)<0.2samples <- run(start, 100)sapply(samples, target)
visitation.matrix
samples <- run(start, 100)
samples
hist(sapply(samples, target))
start <- runif(15)<0.2samples <- run(start, 1000)hist(sapply(samples, target))
start <- runif(15)<0.2samples <- run(start, 10000)hist(sapply(samples, target))
max(sapply(samples, target))
which(sapply(samples, target))
which(sapply(samples, target)==9)
samples[which(sapply(samples, target)==9)]
setwd("~/Documents/phd/brite/tool/mcmc")rm(list=ls())## create sample datasetnum.pollinators <- 25num.plants <- 50visitation <- (runif(num.pollinators*num.plants)<0.2)*1visitation.matrix <- matrix(visitation,                            nrow=num.pollinators, ncol=num.plants)## pollinator.flight.periods## plant.phenologiesrs <- rowSums(visitation.matrix)id.non.supported.pollinator <- which(rs==0)visitation.matrixmost.pollinators <- function(m)  sum(rowSums(visitation.matrix[,m])>0)## MCMC Stufftarget <- most.pollinatorsproposal <- function(m) {  x1 <- sample(which(m), size=1)  x2 <- sample(which(!m), size=1)  m[x1] <- !m[x1]  m[x2] <- !m[x2]  m}step <- function(m) { m.p <- proposal(m) alpha <- target(m.p) / target(m) if ( alpha > 1 || runif(1) < alpha ) m.p else m}run <- function(m, nsteps) { out <- vector(mode="list", length=nsteps) for ( i in seq_len(nsteps) )   m <- out[[i]] <- step(m) out}
start <- runif(15)<0.2samples <- run(start, 100)
start <- runif(15)<0.2samples <- run(start, 1000)
samples
start <- runif(15)<0.2samples <- run(start, 10000)
sapply(samples, target)
hist(sapply(samples, target))
visitation.matrix
sum(start)
start
start <- runif(15)<0.5samples <- run(start, 1000)
hist(sapply(samples, target))
sum(start)
start <- runif(15)<0.3samples <- run(start, 1000)hist(sapply(samples, target))
